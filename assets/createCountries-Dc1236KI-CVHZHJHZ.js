import{B as D,a as F,M as U,D as S,b as H,Z as j,V as L,u as k,L as _,c as I}from"./index-BxG-wGSt.js";function R(i,d=!1){const n=i[0].index!==null,f=new Set(Object.keys(i[0].attributes)),t=new Set(Object.keys(i[0].morphAttributes)),c={},u={},g=i[0].morphTargetsRelative,s=new D;let a=0;for(let e=0;e<i.length;++e){const o=i[e];let l=0;if(n!==(o.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const r in o.attributes){if(!f.has(r))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+r+'" attribute exists among all geometries, or in none of them.'),null;c[r]===void 0&&(c[r]=[]),c[r].push(o.attributes[r]),l++}if(l!==f.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(g!==o.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const r in o.morphAttributes){if(!t.has(r))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;u[r]===void 0&&(u[r]=[]),u[r].push(o.morphAttributes[r])}if(d){let r;if(n)r=o.index.count;else if(o.attributes.position!==void 0)r=o.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;s.addGroup(a,r,e),a+=r}}if(n){let e=0;const o=[];for(let l=0;l<i.length;++l){const r=i[l].index;for(let m=0;m<r.count;++m)o.push(r.getX(m)+e);e+=i[l].attributes.position.count}s.setIndex(o)}for(const e in c){const o=z(c[e]);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;s.setAttribute(e,o)}for(const e in u){const o=u[e][0].length;if(o===0)break;s.morphAttributes=s.morphAttributes||{},s.morphAttributes[e]=[];for(let l=0;l<o;++l){const r=[];for(let y=0;y<u[e].length;++y)r.push(u[e][y][l]);const m=z(r);if(!m)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;s.morphAttributes[e].push(m)}}return s}function z(i){let d,n,f,t=-1,c=0;for(let a=0;a<i.length;++a){const e=i[a];if(d===void 0&&(d=e.array.constructor),d!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(n===void 0&&(n=e.itemSize),n!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(f===void 0&&(f=e.normalized),f!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(t===-1&&(t=e.gpuType),t!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;c+=e.count*n}const u=new d(c),g=new F(u,n,f);let s=0;for(let a=0;a<i.length;++a){const e=i[a];if(e.isInterleavedBufferAttribute){const o=s/n;for(let l=0,r=e.count;l<r;l++)for(let m=0;m<n;m++){const y=e.getComponent(l,m);g.setComponent(l+o,m,y)}}else u.set(e.array,s);s+=e.count*n}return t!==void 0&&(g.gpuType=t),g}async function V(i,d,n=[],f=!1,t={}){const c=t.highlightColor||"#ffffff",u=t.defaultColor||"#000000",g=t.outlineColor||"#ffffff",s=t.globalOpacity!==void 0?t.globalOpacity:1,a=t.progressiveLoading!==void 0?t.progressiveLoading:!0,e=t.batchSize||20,o=performance.now();console.log(`Loading countries from: ${d} (Progressive: ${a}, Batch: ${e})`);const l=await(await fetch(d)).json(),r=performance.now()-o;console.log(`Loaded ${l.features.length} countries in ${r.toFixed(0)}ms`);const m=[],y=[],p=[];let T=0,v=0;const G=x=>{const h=Math.min(x+e,l.features.length);for(let b=x;b<h;b++){const A=l.features[b],E=A.properties,w=n.some(M=>E.ADM0_A3===M||E.ISO_A3===M||E.GU_A3===M||E.SOV_A3===M);try{const M=t.countryRadius||1.01,B=P(A,w,M,t);B.fill&&(w?m.push(B.fill):y.push(B.fill)),B.outlines&&p.push(...B.outlines),T++}catch(M){console.error(`Failed to create country ${E.ADM0_A3||E.NAME}:`,M),v++}}return h<l.features.length?a?new Promise(b=>{setTimeout(()=>b(G(h)),0)}):G(h):(O(),l)},O=()=>{if(m.length>0){const h=R(m,!1),b=t.countryOpacity!==void 0?t.countryOpacity:1,A=Math.max(0,Math.min(1,b*s)),E=new U({color:c,side:S,transparent:A<1,opacity:A}),w=new H(h,E);w.renderOrder=3,i.add(w)}if(y.length>0){const h=R(y,!1),b=t.countryOpacity!==void 0?t.countryOpacity:1,A=Math.max(0,Math.min(1,b*s)),E=new U({color:u,side:S,transparent:A<1,opacity:A}),w=new H(h,E);w.renderOrder=3,i.add(w)}p.forEach(h=>{if(h.material){h.material.color.setStyle(g);const b=t.outlineOpacity!==void 0?t.outlineOpacity:1,A=Math.max(0,Math.min(1,b*s));h.material.opacity=A,h.material.transparent=A<1}i.add(h)});const x=performance.now()-o;console.log(`Total render time: ${x.toFixed(0)}ms (${T} success, ${v} failed)`)};return G(0)}function P(i,d,n,f){const{type:t,coordinates:c}=i.geometry,u=[],g=[];if(t==="Polygon"){const s=C(c[0],n,f);s&&u.push(s);const a=$(c,n+.002,f);g.push(...a)}else t==="MultiPolygon"&&c.forEach(s=>{const a=C(s[0],n,f);a&&u.push(a);const e=$(s,n+.002,f);g.push(...e)});return{fill:u.length>0?R(u,!1):null,outlines:g}}function C(i,d,n){try{return j(i,d,n)}catch(f){return console.error("Failed to create polygon geometry:",f),null}}function $(i,d,n){const f=[];return i.forEach(t=>{let c=0;for(let p=0;p<t.length-1;p++){const[T,v]=t[p],[G,O]=t[p+1],x=G-T,h=O-v;c+=Math.sqrt(x*x+h*h)}const u=c/(t.length-1),g=Number.isFinite(n.outlineDetail)?n.outlineDetail:1,s=Math.ceil(u/2)*g,a=Math.max(2,Math.min(12,Math.ceil(s))),e=[];for(let p=0;p<t.length-1;p++){const T=L(t[p],t[p+1],a);e.push(...T.slice(0,-1))}const o=L(t[t.length-1],t[0],a);e.push(...o.slice(0,-1));const l=e.map(([p,T])=>k(T,p,d)),r=new D().setFromPoints(l),m=new _({color:16777215,linewidth:1,depthTest:!0,depthWrite:!1}),y=new I(r,m);y.renderOrder=4,f.push(y)}),f}export{V as loadCountries};
